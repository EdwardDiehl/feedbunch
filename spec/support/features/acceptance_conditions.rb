##
# Test that a user is logged in, during an acceptance test.
#
# To see if the user is logged in, we check the presence of a "Logout" link in the navbar.

def user_should_be_logged_in
  page.should have_css 'div.navbar #user-dropdown'
end

##
# Test that a user is not logged in, during an acceptance test.
#
# To see if the user is not logged in, we check the absence of a "Logout" link in the navbar.

def user_should_not_be_logged_in
  page.should_not have_css 'div.navbar div.navbar-inner ul li a#sign_out'
end

##
# Test that an email has been sent during acceptance testing. Accepts the following optional named arguments:
#
# - path - if passed, tests that the mail contains a link to this path. Ideally we'd like to test using full URLs
# but this not possible because during testing links inside emails generated by ActionMailer use the hostname
# "www.example.com" instead of the actual "localhost:3000" returned by Rails URL helpers.
# - to - if passed, tests that this is the value of the email's "to" header.
# - text - if passed, tests that this text is present in the email body
#
# Return value is the href of the link if "path" option is passed, nil otherwise.

def mail_should_be_sent(path: nil, to: nil, text: nil)
  email = ActionMailer::Base.deliveries.pop
  email.present?.should be_true

  if to.present?
    email.to.first.should eq to
  end

  # Test only the first part of a multipart email (normally html and text versions are sent at once)
  if email.multipart?
    email = email.parts[0]
  end

  if path.present?
    emailBody = Nokogiri::HTML email.body.to_s
    link = emailBody.at_css "a[href*=\"#{path}\"]"
    link.present?.should be_true
    href = link[:href]
  end

  if text.present?
    email.body.to_s.should include text
  end

  return href
end

##
# Test that no email has been sent during acceptance testing

def mail_should_not_be_sent
  email = ActionMailer::Base.deliveries.pop
  email.present?.should be_false
end

##
# Test that the count of unread entries in a folder equals the passed argument.
# Receives as argument the folder and the expected entry count.

def unread_folder_entries_should_eq(folder, count)
  open_folder folder
  within "#sidebar #folders-list #folder-#{folder.id} #feeds-#{folder.id} #folder-#{folder.id}-all-feeds span.badge" do
    page.should have_content "#{count}"
  end
end

##
# Test that the count of unread entries in a feed equals the passed argument.
# Receives as arguments:
# - the feed to look at
# - the expected entry count
# - the user performing the action

def unread_feed_entries_should_eq(feed, count, user)
  folder = feed.user_folder user
  folder_id = folder.try(:id) || 'none'
  open_folder folder if folder.present?
  within "#sidebar #folders-list #folder-#{folder_id} a[data-sidebar-feed][data-feed-id='#{feed.id}'] span.badge" do
    page.should have_content "#{count}"
  end
end

##
# Test that an alert with the passed id is shown on the page, and that it disappears automatically
# after 5 seconds.

def should_show_alert(alert_id)
  page.should have_css "div##{alert_id}", visible: true

  # It should close automatically after 5 seconds
  sleep 5
  page.should_not have_css "div##{alert_id}", visible: true
end

##
# Test that an alert with the passed id is hidden-

def should_hide_alert(alert_id)
  page.should_not have_css "div##{alert_id}", visible: true
end

##
# Test that the passed entry is visible but marked as read

def entry_should_be_marked_read(entry)
  page.should have_css "a[data-entry-id='#{entry.id}'].entry-read"
end

##
# Test that the passed entry is visible and marked as unread

def entry_should_be_marked_unread(entry)
  page.should have_css "a[data-entry-id='#{entry.id}'].entry-unread"
end